#include "Toolkit/AssetTypes/AnimationBlueprintAssetSerializer.h"
#include "PropertySerializer.h"
#include "Animation/AnimBlueprintGeneratedClass.h"

void UAnimationBlueprintAssetSerializer::SerializeAnimBlueprintClass(TSharedPtr<FJsonObject> OutObject, UAnimBlueprintGeneratedClass* Class, UObjectHierarchySerializer* ObjectHierarchySerializer) {
    //Serialize normal blueprint class
    SerializeBlueprintClass(OutObject, Class, ObjectHierarchySerializer);

    UPropertySerializer* PropertySerializer = ObjectHierarchySerializer->GetPropertySerializer<UPropertySerializer>();

    //Serialize baked state machines without any changes, they don't reference any
    //unserializable stuff outside of some custom curve assets and blend profiles
    TArray<TSharedPtr<FJsonValue>> BakedStateMachines;
    for (const FBakedAnimationStateMachine& AnimationStateMachine : Class->BakedStateMachines) {
        TSharedRef<FJsonObject> MachineObject = PropertySerializer->SerializeStruct(FBakedAnimationStateMachine::StaticStruct(), &AnimationStateMachine);
        BakedStateMachines.Add(MakeShareable(new FJsonValueObject(MachineObject)));
    }
    OutObject->SetArrayField(TEXT("BakedStateMachines"), BakedStateMachines);

    //Target skeleton is just an external asset reference
    const int32 TargetSkeletonObjectIndex = ObjectHierarchySerializer->SerializeObject(Class->TargetSkeleton);
    OutObject->SetNumberField(TEXT("TargetSkeleton"), TargetSkeletonObjectIndex);

    //Serialize anim notifies. They can reference external assets such as movie scenes,
    //but overall there shouldn't be any not serializable stuff too
    TArray<TSharedPtr<FJsonValue>> AnimNotifies;
    for (const FAnimNotifyEvent& AnimNotifyEvent : Class->AnimNotifies) {
        TSharedRef<FJsonObject> NotifyEventObject = PropertySerializer->SerializeStruct(FAnimNotifyEvent::StaticStruct(), &AnimNotifyEvent);
        AnimNotifies.Add(MakeShareable(new FJsonValueObject(NotifyEventObject)));
    }
    OutObject->SetArrayField(TEXT("AnimNotifies"), AnimNotifies);

    //Serialize save pose indices (array of indices of SavePose animation nodes)
    //Technically they can be easily reversed by class struct property traversal, but save them to help blueprint decompilation
    TArray<TSharedPtr<FJsonValue>> OrderedSavedPoseIndices;
    for (int32 SavedPoseIndex : Class->OrderedSavedPoseIndices) {
        OrderedSavedPoseIndices.Add(MakeShareable(new FJsonValueNumber(SavedPoseIndex)));
    }
    OutObject->SetArrayField(TEXT("OrderedSavedPoseIndices"), OrderedSavedPoseIndices);

    //Serialize sync group names (just to aid with BP decompilation)
    TArray<TSharedPtr<FJsonValue>> SyncGroupNames;
    for (FName SyncGroup : Class->SyncGroupNames) {
        SyncGroupNames.Add(MakeShareable(new FJsonValueString(SyncGroup.ToString())));
    }
    OutObject->SetArrayField(TEXT("SyncGroupNames"), SyncGroupNames);

    //Serialize exposed value handlers
    //They need some tinkerer before they can be actually serialized properly
    
    //Disable serialization of cached UFunction pointer (there is FName BoundFunction)
    PropertySerializer->DisablePropertySerialization(FExposedValueHandler::StaticStruct(), TEXT("Function"));

    //Serialize ValueHandlerNodeProperty in FExposedValueHandler just as a path because it will always point to struct property
    //generated by animation graph node in animation blueprint class
    PropertySerializer->SetCustomSerializer(FExposedValueHandler::StaticStruct(), TEXT("ValueHandlerNodeProperty"), [](UProperty* Property, const void* PropertyValue) {
        UObjectProperty* ObjectProperty = CastChecked<UObjectProperty>(Property);
        UProperty* PropertyValueObject = CastChecked<UProperty>(ObjectProperty->GetObjectPropertyValue(PropertyValue));
        
        return MakeShareable(new FJsonValueString(PropertyValueObject->GetName()));
    });

    //Disable serialization of cached UProperty objects in FExposedValueCopyRecord
    PropertySerializer->DisablePropertySerialization(FExposedValueCopyRecord::StaticStruct(), TEXT("CachedSourceProperty"));
    PropertySerializer->DisablePropertySerialization(FExposedValueCopyRecord::StaticStruct(), TEXT("CachedSourceStructSubProperty"));

    //Serialize DestProperty in CachedSourceStructSubProperty as just a string path
    //It will always point either into the generated struct property of the animation node,
    //or directly into the instance struct property. Either way, it will always exist already
    //and resolvable just by property name and extra data in that struct
    PropertySerializer->SetCustomSerializer(FExposedValueCopyRecord::StaticStruct(), TEXT("DestProperty"), [](UProperty* Property, const void* PropertyValue) {
        UObjectProperty* ObjectProperty = CastChecked<UObjectProperty>(Property);
        UProperty* PropertyValueObject = CastChecked<UProperty>(ObjectProperty->GetObjectPropertyValue(PropertyValue));
        
        return MakeShareable(new FJsonValueString(PropertyValueObject->GetName()));
    });

    //Now we can just perform normal serialization
    TArray<TSharedPtr<FJsonValue>> ExposedValueHandlers;
    for (const FExposedValueHandler& ExposedValueHandler : Class->EvaluateGraphExposedInputs) {
        TSharedRef<FJsonObject> SerializedStruct = PropertySerializer->SerializeStruct(FExposedValueHandler::StaticStruct(), &ExposedValueHandler);
        ExposedValueHandlers.Add(MakeShareable(new FJsonValueObject(SerializedStruct)));
    }
    OutObject->SetArrayField(TEXT("EvaluateGraphExposedInputs"), ExposedValueHandlers);
}

EAssetCategory UAnimationBlueprintAssetSerializer::GetAssetCategory() const {
    return EAssetCategory::EAC_AnimationBlueprint;
}

void UAnimationBlueprintAssetSerializer::SerializeClassInternal(TSharedPtr<FJsonObject> OutObject, UBlueprintGeneratedClass* Class, UObjectHierarchySerializer* ObjectHierarchySerializer) const {
    //Make sure we are serialized this exact generated class type and not some child
    check(Class->GetClass() == UAnimBlueprintGeneratedClass::StaticClass());
    
    SerializeAnimBlueprintClass(OutObject, CastChecked<UAnimBlueprintGeneratedClass>(Class), ObjectHierarchySerializer);
}
